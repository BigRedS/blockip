#! /usr/bin/perl

use strict;

no warnings;

use Sys::Syslog;
use Data::Dumper;
use Getopt::Long;
use Socket qw( inet_ntoa );
use Sys::Syslog qw(:standard :macros);

use Net::Subnet;  # libnet-subnet-perl
use Config::Tiny;  # libconfig-tiny-perl 

my $command_line = join(" ", $0, @ARGV);

# This is the package-supplied one
my $f_config;
if(-f './blockip.static'){
	$f_config = './blockip.static';
}else{
	$f_config = '/etc/blockip/blockip.static';
}
# This is the home-made one
my $f_local_config;
if(-f './blockip.conf'){
	$f_local_config = './blockip.conf';
}else{
	$f_local_config = '/etc/blockip/blockip.conf';
}

unless(-f $f_local_config){
	print STDERR "Local config file not found (checked ./blockip.conf and $f_local_config)\n";
	print STDERR "Please create one, using\n\n";
	print STDERR "    $0 --example-config > $f_local_config\n\n";
	print STDERR "Or similar; see --help output for more information\n";
}

my $help;
my ($unblock,$noprompt,$debug,$iptables,$dry_run,$config_help,$example_config) = undef;

GetOptions(
	"config-file=s" => \$f_config,
	"debug"         => \$debug,
	"dry-run|d"     => \$dry_run,
	"example-config"=> \$example_config,
	"help|h"        => \$help,
	"iptables"      => \$iptables,
	"no-prompt"     => \$noprompt,
	"unblock"       => \$unblock,
) or die ("Error parsing command-line options");

if($help){
	usage();
	exit;
}
if($example_config){
	example_config();
	exit;
}

openlog("blockip", "nofatal,pid", LOG_DAEMON);
my $ip_address = shift;
syslog("INFO", "Command line: $command_line");

_debug("Config file: $f_config");
my $config;
if($f_config eq '' || ! -f $f_config){
	print "No config file, carrying on with defaults\n";
	$config = {};
}else{
	$config = Config::Tiny->read( $f_config ) or die ("Error reading config file '$f_config' : ".Config::Tiny->errstr);
}
my $local_config = {};
_debug("Local config file: $f_config");
if(-f $f_local_config){
	$local_config = Config::Tiny->read( $f_local_config ) or die ("Error reading config file '$f_local_config' : ".Config::Tiny->errstr);
}

# If we're passed --iptables, then the block_command is overriden to an 
# iptables invocation.
if($iptables){
	$config->{'_'}->{'block_command'}   = 'iptables -A INPUT -s %ip_address% -j DROP';
	$config->{'_'}->{'unblock_command'} = 'iptables -D INPUT -s %ip_address% -j DROP';
}

if($unblock){
	syslog("INFO", "Unblocking '$ip_address'");
	unblock_address($ip_address);
	exit;
}

# Get together some lists of addresses to refuse to block:
# Whitelists from the config file:
my $whitelist     = resolve_whitelist($config->{'whitelist'});
my $confirm_first = resolve_whitelist($config->{'confirm-first'});
my $local_whitelist     = resolve_whitelist($local_config->{'whitelist'});
my $local_confirm_first = resolve_whitelist($local_config->{'confirm-first'});

# Never block loopback or private addresses
my $rfc1918 = subnet_matcher qw(10.0.0.0/8 172.16.0.0/12 192.168.0.0/16);
my $loopback = subnet_matcher qw(127.0.0.0/8);

# Abort if the address we've been asked to block is whitelisted:
if(my $message = check_whitelists($ip_address)){
	syslog("INFO", "Refusing to block '$ip_address'");
	_error($message);
}

# We now prompt the user to make sure they do want to block this address; 
# if it is on the confirm-first list

my $input;

my($reason,$file);
if(($reason,$file) = check_confirm_firsts($ip_address) and $reason =~ m/.+/){
	print "Address '$ip_address' is listed as confirm-first in $file\n";
	print "Reason given:\n  $reason\n\n";
	print "Are you sure you want to block this address? [Y/n] ";
	$input = <STDIN>;
	unless($input =~ m/^y$/i){
		print "Aborting\n";
		exit;
	}
}

# Block the address:
syslog("INFO", "Blocking '$ip_address'");
block_address($ip_address);
syslog("INFO", "Exiting");
# # #
# #
#

sub block_address{
	my $ip_address = shift;
	my $cmd;
	if($cmd = $config->{'_'}->{'block_command'}){
		$cmd =~ s/%ip_address%/$ip_address/;
	}else{
		$cmd = "ip route add blackhole $ip_address";
	}
	_debug("Block command: $cmd");
	syslog("INFO", "Block command: '$cmd'");
	if($dry_run){
		syslog("INFO", "Called with dry-run, exiting without blocking");
		print "Called with dry-run, exiting without blocking\n";
		print "Would have executed:\n $cmd\n";
		return;
	}
	my $output = `$cmd 2>&1`;
	if($? != 0){
		syslog("INFO", "FAILED. Aborting");
		print "Command ($cmd) FAILED\n";
		print $output;
	}
	syslog("INFO", "Exited: $?");
}

sub unblock_address{
	my $ip_address = shift;
	my $cmd;
	if($cmd = $config->{'_'}->{'unblock_command'}){
		$cmd =~ s/%ip_address%/$ip_address/;
	}else{
		$cmd = "ip route del blackhole $ip_address";
	}
	syslog("INFO", "Unblock command: '$cmd'");
	_debug("Unblock command: $cmd");
	if($dry_run){
		syslog("INFO", "Called with dry-run, exiting without unblocking");
		print "Called with dry-run, exiting without unblocking\n";
		print "Would have executed:\n $cmd\n";

		return;
	}
	my $output = `$cmd 2>&1`;
	if($? != 0){
		syslog("INFO", "FAILED. Aborting");
		print "Command ($cmd) FAILED\n";
		print $output;
	}
	syslog("INFO", "Exited: $?");
}

# Is passed an IP address, checks all the whitelists for its presence. 
sub check_whitelists{
	my $ip_address = shift;

	if($ip_address eq ""){
		return ("You didn't specify an IP address. Perhaps see --help output?");
	}

	unless($ip_address =~ m/(\d+)\.(\d+)\.(\d+)\.(\d+)/){
		return("'$ip_address' does not look like a valid IP address; needs to be four octets. (try with --help?)");
	}
	unless($1 <= 256 && $2 <= 256 && $3 <= 256 && $4 <= 256){
		return("'$ip_address' does not look like a valid IP address; no octet may be greater than 256");
	}
	
	if($rfc1918->($ip_address)){
		return("$ip_address is an RFC1918 (private, not-routable) address. Do not block it.");
	}
	
	if($loopback->($ip_address)){
		return("$ip_address is a loopback address. Do not block it.");
	}

	foreach my $reason (keys(%{$local_whitelist})){
		_debug ("Subnet matching $reason: ". join(",", @{$local_whitelist->{$reason}}));
		my $networks = subnet_matcher(@{$local_whitelist->{$reason}}); 
		if($networks->($ip_address)){
			return "$ip_address is whitelisted, as '$reason'";
		}
	}

	foreach my $reason (keys(%{$whitelist})){
		_debug ("Subnet matching $reason: ". join(",", @{$whitelist->{$reason}}));
		my $networks = subnet_matcher(@{$whitelist->{$reason}}); 
		if($networks->($ip_address)){
			return "$ip_address is whitelisted, as '$reason'";
		}
	}


	return undef;
}

sub check_confirm_firsts{
	my $ip_address = shift;
	foreach my $reason (keys(%{$local_confirm_first})){
		_debug ("Subnet matching local confirm-first $reason: ".join("," , @{$local_confirm_first->{$reason}}));
		my $networks = subnet_matcher(@{$local_confirm_first->{$reason}}); 
		if($networks->($ip_address)){
			return ($reason, $f_local_config);
		}
	}

	foreach my $reason (keys(%{$confirm_first})){
		_debug ("Subnet matching confirm-first $reason: ".join("," , @{$confirm_first->{$reason}}));
		my $networks = subnet_matcher(@{$confirm_first->{$reason}}); 
		if($networks->($ip_address)){
			return ($reason, $f_config);
		}
	}
	return undef;
}
		

# Takes a whitelist as returned by the config (a hashref, with IP 
# addresses/CIDR masks as keys, reasons as values) and returns as 
# a hashref with reasons as keys and an arrayref of IP addresses/
# CIDR masks as values. 
sub resolve_whitelist{
	my $whitelist = shift;
	my $return;
	foreach my $ip_address (keys(%{$whitelist})){
		my $reason = $whitelist->{$ip_address};
		next if ($ip_address =~ m/^\d+\.\d+\.\d+\.\d+/);
		_debug("Resolving whitelisted domain '$ip_address'");
		my @addresses = gethostbyname($ip_address);
		@addresses = map { inet_ntoa($_) } @addresses[ 4 .. $#addresses ];
		foreach my $record ( @addresses ) {
			$whitelist->{$record} = $reason;
		}
		delete($whitelist->{$ip_address});
	}
	foreach my $ip_address (keys(%{$whitelist})){
		my $reason = $whitelist->{$ip_address};
		$ip_address.="/32" unless $ip_address =~ m/\/\d+$/;
		push(@{$return->{$reason}}, $ip_address);
	}
	return $return;
}

sub _error{
	my $message = shift;
	chomp($message);
	print STDERR $message, "\n";
	exit 1;
}

sub _debug{
	return unless $debug;
	my $message = shift;
	chomp($message);
	print STDERR $message, "\n";
}

sub usage{
print <<"EOF";
blockip

   Safely prevents hosts reaching this machine. 

usage:

   blockip <options> host

Options:

    --config-file <file>    use <file> as config file. Default: $f_config 
    --debug                 print debugging output
    --dry-run               run through all the checks, but don't (un)block
    --example-config        print out an example blockip.conf
    --help                  see this help
    --iptables              use iptables for block/unblock (overrides config file)
    --config-help           see config file help
    --no-prompt             don't prompt for confirmation (for scripts)
    --unblock               unblock IP address

The unblocking may not work; it assumes that the IP address has been blocked
in the same way as blockip is configured to (see 'block_command' and 
'unblock_command' in the config file).


blockip has two configuration files. blockip.static is provided by the 
package manager, and should not be edited by anybody else. It contains just a 
whitelist and confirm-first list.

blockip.conf is for normal human consumption, and may contain all config 
options. It is created on package installation. You can recreate it with

blockip --example-config > /etc/blockip/blockip.conf

EOF
}

sub example_config{
print STDOUT << "EOF";
# block_command and unblock_command are executed when blocking and unblocking 
# an address, respectively. The default is to use `ip route add blackhole` and 
# `ip route del blackhole`
# There is one available variable, %ip_address%, which is the address to be 
# blocked or re-permitted:

#block_command = ip route add blackhole %ip_address%
#unblock_command = ip route del blackhole %ip_address%

# The whitelist and confirm-before list must come *after* any other directives.
#
# Each is a list of elements of the form
#
# <address> = <name>
#
# Where <address> may be an IP address, a network in CIDR notation, or a DNS 
# name. The 'name' is simply a string used to tell a user why they ought not 
# delete this address.

# Whitelisted addresses may not be blocked. RFC1918 and loopback ones are 
# hardcoded into the script:
#  [whitelist]
#  1.2.3.4 = Example address

# Confirm-first addresses may be blocked, but the user will first be prompted
# with the label given here, in case that makes them change their mind. They
# are intended for things like search engine bots:
#  [confirm-first]
#  216.58.213.100 = Google Bot

EOF
}
